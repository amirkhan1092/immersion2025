

### 1. **Two Pointers Technique**
This technique involves using two pointers to traverse the data structure. It’s often used for problems involving sorted arrays or lists.

**Problems:**
- **Problem 1:** Find the two numbers in a sorted array that sum up to a specific target.
- **Problem 2:** Remove duplicates from a sorted array.
- **Problem 3:** Find the maximum sum of a contiguous subarray (Kadane's algorithm).

### 2. **Sliding Window**
This technique is useful for problems involving subarrays or substrings, where you need to find a particular condition in a contiguous block of elements.

**Problems:**
- **Problem 1:** Find the length of the longest substring without repeating characters.
- **Problem 2:** Given an array, find the maximum sum of any contiguous subarray of size `k`.
- **Problem 3:** Given a string, find the longest substring with at most `k` distinct characters.

### 3. **Binary Search**
Binary search is an efficient algorithm for finding an item from a sorted list of items, reducing the search space by half at each step.

**Problems:**
- **Problem 1:** Search for a target value in a sorted array.
- **Problem 2:** Find the first and last position of a target value in a sorted array.
- **Problem 3:** Find the square root of a given number using binary search.

### 4. **Dynamic Programming**
Dynamic programming is used for optimization problems where the solution can be broken down into smaller overlapping subproblems.

**Problems:**
- **Problem 1:** Find the nth Fibonacci number using dynamic programming.
- **Problem 2:** Given an array of integers, find the maximum sum of non-adjacent numbers (House Robber problem).
- **Problem 3:** Find the minimum number of coins needed to make a given amount (Coin Change problem).

### 5. **Backtracking**
Backtracking is an algorithmic technique for solving problems incrementally by trying partial solutions and then abandoning them if they’re not valid.

**Problems:**
- **Problem 1:** Solve the N-Queens problem.
- **Problem 2:** Generate all possible subsets of a set (Power Set).
- **Problem 3:** Solve the Sudoku puzzle.

### 6. **Greedy Algorithms**
Greedy algorithms make the locally optimal choice at each stage with the hope of finding a global optimum.

**Problems:**
- **Problem 1:** Find the minimum number of platforms required for a railway station (Platform problem).
- **Problem 2:** Coin change problem, where you need to make change with the fewest coins.
- **Problem 3:** Activity selection problem: select the maximum number of activities that don’t overlap.

### 7. **Hashing**
Using a hash table to store and quickly access data based on keys, which is useful for problems involving frequency counts or fast lookups.

**Problems:**
- **Problem 1:** Check if two strings are anagrams of each other.
- **Problem 2:** Find the first non-repeating character in a string.
- **Problem 3:** Group anagrams from a list of strings.

### 8. **Depth-First Search (DFS) and Breadth-First Search (BFS)**
These techniques are used for traversing or searching tree or graph data structures.

**Problems:**
- **Problem 1:** Given a binary tree, find its maximum depth (DFS).
- **Problem 2:** Find the shortest path in an unweighted graph (BFS).
- **Problem 3:** Check if a graph is bipartite (DFS/BFS).

### 9. **Sorting Algorithms**
Understanding sorting algorithms can help with solving various problems efficiently.

**Problems:**
- **Problem 1:** Implement quicksort or mergesort and analyze their time complexity.
- **Problem 2:** Find the k-th largest element in an unsorted array.
- **Problem 3:** Merge two sorted arrays into one sorted array.

### 10. **Graph Algorithms**
These are specialized algorithms for solving problems related to graphs.

**Problems:**
- **Problem 1:** Implement Dijkstra's algorithm for finding the shortest path in a weighted graph.
- **Problem 2:** Find all connected components in an undirected graph.
- **Problem 3:** Detect a cycle in a directed graph.

